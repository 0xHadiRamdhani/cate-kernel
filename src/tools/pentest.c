#include "pentest.h"
#include "../kernel/memory.h"
#include "../kernel/interrupt.h"
#include "../drivers/vga.h"
#include "../network/network.h"
#include "../security/security.h"
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdarg.h>

/* Global pentest manager */
pentest_manager_t* global_pentest_manager = NULL;
bool pentest_initialized = false;

/* Initialize pentesting subsystem */
void pentest_init(void) {
    if (pentest_initialized) return;
    
    /* Allocate pentest manager */
    global_pentest_manager = (pentest_manager_t*)kmalloc(sizeof(pentest_manager_t));
    if (!global_pentest_manager) return;
    
    memory_zero(global_pentest_manager, sizeof(pentest_manager_t));
    
    /* Initialize manager */
    global_pentest_manager->initialized = true;
    global_pentest_manager->max_concurrent_tools = PENTEST_MAX_CONCURRENT_TOOLS;
    global_pentest_manager->max_concurrent_sessions = PENTEST_MAX_CONCURRENT_SESSIONS;
    global_pentest_manager->default_timeout = PENTEST_DEFAULT_TIMEOUT;
    global_pentest_manager->default_threads = PENTEST_DEFAULT_THREADS;
    global_pentest_manager->default_retries = PENTEST_DEFAULT_RETRIES;
    global_pentest_manager->default_threat_level = PENTEST_DEFAULT_THREAT_LEVEL;
    global_pentest_manager->stealth_mode = false;
    global_pentest_manager->evasion_mode = false;
    global_pentest_manager->encryption_enabled = true;
    global_pentest_manager->logging_enabled = true;
    global_pentest_manager->reporting_enabled = true;
    
    /* Initialize statistics */
    global_pentest_manager->total_sessions = 0;
    global_pentest_manager->total_targets = 0;
    global_pentest_manager->total_vulnerabilities = 0;
    global_pentest_manager->total_exploits = 0;
    global_pentest_manager->total_scans = 0;
    global_pentest_manager->total_attacks = 0;
    global_pentest_manager->total_successes = 0;
    global_pentest_manager->total_failures = 0;
    global_pentest_manager->total_runtime = 0;
    
    /* Initialize security */
    global_pentest_manager->security_level = SECURITY_LEVEL_MEDIUM;
    global_pentest_manager->authentication_required = true;
    global_pentest_manager->authorization_required = true;
    global_pentest_manager->audit_enabled = true;
    
    /* Initialize modes */
    global_pentest_manager->reconnaissance_mode = false;
    global_pentest_manager->scanning_mode = false;
    global_pentest_manager->exploitation_mode = false;
    global_pentest_manager->post_exploitation_mode = false;
    global_pentest_manager->reporting_mode = false;
    
    /* Initialize current session */
    global_pentest_manager->current_session_id = 0;
    global_pentest_manager->current_session = NULL;
    
    pentest_initialized = true;
    
    vga_print_success("Pentesting subsystem initialized");
}

/* Shutdown pentesting subsystem */
void pentest_shutdown(void) {
    if (!pentest_initialized || !global_pentest_manager) return;
    
    /* Stop all active sessions */
    pentest_session_t* session = global_pentest_manager->sessions;
    while (session) {
        pentest_session_t* next = session->next;
        pentest_stop_session(session);
        session = next;
    }
    
    /* Stop all active tools */
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        pentest_tool_t* next = tool->next;
        pentest_stop_tool(tool);
        tool = next;
    }
    
    /* Free all allocated memory */
    /* This would free all allocated resources */
    
    kfree(global_pentest_manager);
    global_pentest_manager = NULL;
    pentest_initialized = false;
    
    vga_print_info("Pentesting subsystem shutdown");
}

/* Check if initialized */
bool pentest_is_initialized(void) {
    return pentest_initialized && global_pentest_manager && global_pentest_manager->initialized;
}

/* Create tool */
pentest_tool_t* pentest_create_tool(pentest_tool_type_t tool_type, const char* name, const char* description) {
    if (!global_pentest_manager || !name) return NULL;
    
    /* Allocate tool */
    pentest_tool_t* tool = (pentest_tool_t*)kmalloc(sizeof(pentest_tool_t));
    if (!tool) return NULL;
    
    memory_zero(tool, sizeof(pentest_tool_t));
    
    /* Initialize tool */
    tool->tool_id = global_pentest_manager->tool_count++;
    strncpy(tool->name, name, sizeof(tool->name) - 1);
    if (description) {
        strncpy(tool->description, description, sizeof(tool->description) - 1);
    }
    tool->tool_type = tool_type;
    tool->enabled = true;
    tool->running = false;
    tool->priority = 50;
    tool->start_time = 0;
    tool->end_time = 0;
    tool->target_count = 0;
    tool->success_count = 0;
    tool->failure_count = 0;
    tool->error_count = 0;
    
    /* Initialize statistics */
    tool->total_runtime = 0;
    tool->total_targets = 0;
    tool->total_successes = 0;
    tool->total_failures = 0;
    tool->total_errors = 0;
    tool->total_bytes_processed = 0;
    tool->average_speed = 0;
    tool->peak_speed = 0;
    
    /* Initialize security features */
    tool->stealth_mode = global_pentest_manager->stealth_mode;
    tool->evasion_mode = global_pentest_manager->evasion_mode;
    tool->encryption_enabled = global_pentest_manager->encryption_enabled;
    tool->authentication_required = global_pentest_manager->authentication_required;
    tool->security_level = global_pentest_manager->security_level;
    
    /* Add to linked list */
    tool->next = global_pentest_manager->tools;
    global_pentest_manager->tools = tool;
    
    vga_printf("Created pentest tool: %s (ID: %u, Type: %u)\n", name, tool->tool_id, tool_type);
    return tool;
}

/* Destroy tool */
pentest_status_t pentest_destroy_tool(pentest_tool_t* tool) {
    if (!tool) return PENTEST_STATUS_INVALID_PARAM;
    
    /* Remove from linked list */
    pentest_tool_t** current = &global_pentest_manager->tools;
    while (*current) {
        if (*current == tool) {
            *current = tool->next;
            
            /* Free private data */
            if (tool->private_data) {
                kfree(tool->private_data);
            }
            
            kfree(tool);
            global_pentest_manager->tool_count--;
            return PENTEST_STATUS_OK;
        }
        current = &(*current)->next;
    }
    
    return PENTEST_STATUS_NOT_FOUND;
}

/* Get tool by ID */
pentest_tool_t* pentest_get_tool(uint32_t tool_id) {
    if (!global_security_manager) return NULL;
    
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        if (tool->tool_id == tool_id) {
            return tool;
        }
        tool = tool->next;
    }
    
    return NULL;
}

/* Get tool by name */
pentest_tool_t* pentest_get_tool_by_name(const char* name) {
    if (!global_pentest_manager || !name) return NULL;
    
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        if (strcmp(tool->name, name) == 0) {
            return tool;
        }
        tool = tool->next;
    }
    
    return NULL;
}

/* Get tool count */
uint32_t pentest_get_tool_count(void) {
    return global_pentest_manager ? global_pentest_manager->tool_count : 0;
}

/* Create session */
pentest_session_t* pentest_create_session(const char* name, const char* description) {
    if (!global_pentest_manager || !name) return NULL;
    
    /* Allocate session */
    pentest_session_t* session = (pentest_session_t*)kmalloc(sizeof(pentest_session_t));
    if (!session) return NULL;
    
    memory_zero(session, sizeof(pentest_session_t));
    
    /* Initialize session */
    session->session_id = global_pentest_manager->session_count++;
    strncpy(session->name, name, sizeof(session->name) - 1);
    if (description) {
        strncpy(session->description, description, sizeof(session->description) - 1);
    }
    session->target_count = 0;
    session->targets = NULL;
    session->tool_count = 0;
    session->tools = NULL;
    session->scan_count = 0;
    session->scans = NULL;
    session->vulnerability_count = 0;
    session->vulnerabilities = NULL;
    session->exploit_count = 0;
    session->exploits = NULL;
    session->start_time = 0;
    session->end_time = 0;
    session->duration = 0;
    session->flags = 0;
    session->threat_level = PENTEST_DEFAULT_THREAT_LEVEL;
    session->active = false;
    session->completed = false;
    session->compromised = false;
    session->success_rate = 0;
    session->coverage = 0;
    session->report_file[0] = '\0';
    session->log_file[0] = '\0';
    
    /* Add to linked list */
    session->next = global_pentest_manager->sessions;
    global_pentest_manager->sessions = session;
    
    vga_printf("Created pentest session: %s (ID: %u)\n", name, session->session_id);
    return session;
}

/* Destroy session */
pentest_status_t pentest_destroy_session(pentest_session_t* session) {
    if (!session) return PENTEST_STATUS_INVALID_PARAM;
    
    /* Remove from linked list */
    pentest_session_t** current = &global_pentest_manager->sessions;
    while (*current) {
        if (*current == session) {
            *current = session->next;
            
            /* Free allocated resources */
            if (session->targets) kfree(session->targets);
            if (session->tools) kfree(session->tools);
            if (session->scans) kfree(session->scans);
            if (session->vulnerabilities) kfree(session->vulnerabilities);
            if (session->exploits) kfree(session->exploits);
            
            kfree(session);
            global_pentest_manager->session_count--;
            return PENTEST_STATUS_OK;
        }
        current = &(*current)->next;
    }
    
    return PENTEST_STATUS_NOT_FOUND;
}

/* Get session by ID */
pentest_session_t* pentest_get_session(uint32_t session_id) {
    if (!global_pentest_manager) return NULL;
    
    pentest_session_t* session = global_pentest_manager->sessions;
    while (session) {
        if (session->session_id == session_id) {
            return session;
        }
        session = session->next;
    }
    
    return NULL;
}

/* Get current session */
pentest_session_t* pentest_get_current_session(void) {
    return global_pentest_manager ? global_pentest_manager->current_session : NULL;
}

/* Get session count */
uint32_t pentest_get_session_count(void) {
    return global_pentest_manager ? global_pentest_manager->session_count : 0;
}

/* Start session */
pentest_status_t pentest_start_session(pentest_session_t* session) {
    if (!session) return PENTEST_STATUS_INVALID_PARAM;
    if (session->active) return PENTEST_STATUS_ERROR;
    
    session->start_time = get_system_time();
    session->active = true;
    session->completed = false;
    
    /* Set as current session */
    global_pentest_manager->current_session = session;
    global_pentest_manager->current_session_id = session->session_id;
    
    global_pentest_manager->total_sessions++;
    
    vga_printf("Started pentest session: %s\n", session->name);
    return PENTEST_STATUS_OK;
}

/* Stop session */
pentest_status_t pentest_stop_session(pentest_session_t* session) {
    if (!session) return PENTEST_STATUS_INVALID_PARAM;
    if (!session->active) return PENTEST_STATUS_ERROR;
    
    session->end_time = get_system_time();
    session->duration = (uint32_t)(session->end_time - session->start_time);
    session->active = false;
    session->completed = true;
    
    /* Clear current session if this is it */
    if (global_pentest_manager->current_session == session) {
        global_pentest_manager->current_session = NULL;
        global_pentest_manager->current_session_id = 0;
    }
    
    vga_printf("Stopped pentest session: %s (Duration: %u seconds)\n", session->name, session->duration);
    return PENTEST_STATUS_OK;
}

/* Create target */
pentest_target_t* pentest_create_target(const char* name, const char* ip_address) {
    if (!global_pentest_manager || !name || !ip_address) return NULL;
    
    /* Allocate target */
    pentest_target_t* target = (pentest_target_t*)kmalloc(sizeof(pentest_target_t));
    if (!target) return NULL;
    
    memory_zero(target, sizeof(pentest_target_t));
    
    /* Initialize target */
    target->target_id = global_pentest_manager->target_count++;
    strncpy(target->name, name, sizeof(target->name) - 1);
    strncpy(target->ip_address, ip_address, sizeof(target->ip_address) - 1);
    target->ip_int = network_ip_string_to_int(ip_address);
    target->hostname[0] = '\0';
    target->description[0] = '\0';
    target->open_port_count = 0;
    target->service_count = 0;
    target->operating_system[0] = '\0';
    target->version[0] = '\0';
    target->architecture[0] = '\0';
    target->vulnerability_count = 0;
    target->alive = false;
    target->reachable = false;
    target->response_time = 0;
    target->hop_count = 0;
    target->threat_level = PENTEST_DEFAULT_THREAT_LEVEL;
    target->critical = false;
    target->exploited = false;
    target->compromised = false;
    target->discovered_time = get_system_time();
    target->last_scan = 0;
    target->last_exploit = 0;
    target->exploit_count = 0;
    target->scan_count = 0;
    target->flags = 0;
    
    global_pentest_manager->total_targets++;
    
    vga_printf("Created pentest target: %s (%s)\n", name, ip_address);
    return target;
}

/* Destroy target */
pentest_status_t pentest_destroy_target(pentest_target_t* target) {
    if (!target) return PENTEST_STATUS_INVALID_PARAM;
    
    kfree(target);
    return PENTEST_STATUS_OK;
}

/* Get target by ID */
pentest_target_t* pentest_get_target(uint32_t target_id) {
    if (!global_pentest_manager) return NULL;
    
    /* This would search through all sessions for the target */
    pentest_session_t* session = global_pentest_manager->sessions;
    while (session) {
        for (uint32_t i = 0; i < session->target_count; i++) {
            if (session->targets[i].target_id == target_id) {
                return &session->targets[i];
            }
        }
        session = session->next;
    }
    
    return NULL;
}

/* Get target by IP */
pentest_target_t* pentest_get_target_by_ip(const char* ip_address) {
    if (!global_pentest_manager || !ip_address) return NULL;
    
    /* This would search through all sessions for the target */
    pentest_session_t* session = global_pentest_manager->sessions;
    while (session) {
        for (uint32_t i = 0; i < session->target_count; i++) {
            if (strcmp(session->targets[i].ip_address, ip_address) == 0) {
                return &session->targets[i];
            }
        }
        session = session->next;
    }
    
    return NULL;
}

/* Get target count */
uint32_t pentest_get_target_count(void) {
    return global_pentest_manager ? global_pentest_manager->target_count : 0;
}

/* Start port scan */
pentest_status_t pentest_start_port_scan(pentest_session_t* session, pentest_target_t* target, uint16_t start_port, uint16_t end_port) {
    if (!session || !target) return PENTEST_STATUS_INVALID_PARAM;
    if (start_port > end_port || end_port > PORT_MAX) return PENTEST_STATUS_INVALID_PARAM;
    
    vga_printf("Starting port scan of %s (%s) from port %u to %u\n", 
               target->name, target->ip_address, start_port, end_port);
    
    /* This would implement actual port scanning logic */
    /* For now, simulate some open ports */
    target->open_port_count = 3;
    target->open_ports[0] = 80;
    target->open_ports[1] = 443;
    target->open_ports[2] = 22;
    
    target->scan_count++;
    target->last_scan = get_system_time();
    
    session->scan_count++;
    
    return PENTEST_STATUS_OK;
}

/* Start vulnerability scan */
pentest_status_t pentest_start_vulnerability_scan(pentest_session_t* session, pentest_target_t* target) {
    if (!session || !target) return PENTEST_STATUS_INVALID_PARAM;
    
    vga_printf("Starting vulnerability scan of %s (%s)\n", target->name, target->ip_address);
    
    /* This would implement actual vulnerability scanning logic */
    /* For now, simulate some vulnerabilities */
    target->vulnerability_count = 2;
    
    target->scan_count++;
    target->last_scan = get_system_time();
    
    session->scan_count++;
    
    return PENTEST_STATUS_OK;
}

/* Stop scan */
pentest_status_t pentest_stop_scan(pentest_session_t* session) {
    if (!session) return PENTEST_STATUS_INVALID_PARAM;
    
    vga_printf("Stopping scans in session: %s\n", session->name);
    return PENTEST_STATUS_OK;
}

/* Start exploitation */
pentest_status_t pentest_start_exploitation(pentest_session_t* session, pentest_target_t* target, pentest_vulnerability_t* vulnerability) {
    if (!session || !target || !vulnerability) return PENTEST_STATUS_INVALID_PARAM;
    
    vga_printf("Starting exploitation of %s (%s) using vulnerability: %s\n", 
               target->name, target->ip_address, vulnerability->name);
    
    /* This would implement actual exploitation logic */
    target->exploited = true;
    target->exploit_count++;
    target->last_exploit = get_system_time();
    
    global_pentest_manager->total_attacks++;
    
    return PENTEST_STATUS_OK;
}

/* Stop exploitation */
pentest_status_t pentest_stop_exploitation(pentest_session_t* session) {
    if (!session) return PENTEST_STATUS_INVALID_PARAM;
    
    vga_printf("Stopping exploitation in session: %s\n", session->name);
    return PENTEST_STATUS_OK;
}

/* Set stealth mode */
pentest_status_t pentest_set_stealth_mode(bool enable) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->stealth_mode = enable;
    
    /* Update all tools */
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        tool->stealth_mode = enable;
        tool = tool->next;
    }
    
    vga_printf("Stealth mode %s\n", enable ? "enabled" : "disabled");
    return PENTEST_STATUS_OK;
}

/* Set evasion mode */
pentest_status_t pentest_set_evasion_mode(bool enable) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->evasion_mode = enable;
    
    /* Update all tools */
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        tool->evasion_mode = enable;
        tool = tool->next;
    }
    
    vga_printf("Evasion mode %s\n", enable ? "enabled" : "disabled");
    return PENTEST_STATUS_OK;
}

/* Set encryption */
pentest_status_t pentest_set_encryption(bool enable) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->encryption_enabled = enable;
    
    /* Update all tools */
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        tool->encryption_enabled = enable;
        tool = tool->next;
    }
    
    vga_printf("Encryption %s\n", enable ? "enabled" : "disabled");
    return PENTEST_STATUS_OK;
}

/* Set security level */
pentest_status_t pentest_set_security_level(uint8_t level) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    if (level > 5) return PENTEST_STATUS_INVALID_PARAM;
    
    global_pentest_manager->security_level = level;
    
    /* Update all tools */
    pentest_tool_t* tool = global_pentest_manager->tools;
    while (tool) {
        tool->security_level = level;
        tool = tool->next;
    }
    
    vga_printf("Security level set to %u\n", level);
    return PENTEST_STATUS_OK;
}

/* Configure timeout */
pentest_status_t pentest_configure_timeout(uint32_t timeout) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->default_timeout = timeout;
    vga_printf("Timeout configured to %u ms\n", timeout);
    return PENTEST_STATUS_OK;
}

/* Configure threads */
pentest_status_t pentest_configure_threads(uint32_t threads) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->default_threads = threads;
    vga_printf("Threads configured to %u\n", threads);
    return PENTEST_STATUS_OK;
}

/* Configure retries */
pentest_status_t pentest_configure_retries(uint32_t retries) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->default_retries = retries;
    vga_printf("Retries configured to %u\n", retries);
    return PENTEST_STATUS_OK;
}

/* Check if stealth mode enabled */
bool pentest_is_stealth_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->stealth_mode : false;
}

/* Check if evasion mode enabled */
bool pentest_is_evasion_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->evasion_mode : false;
}

/* Get security level */
uint8_t pentest_get_security_level(void) {
    return global_pentest_manager ? global_pentest_manager->security_level : 0;
}

/* Get statistics */
void pentest_get_statistics(uint64_t* total_sessions, uint64_t* total_targets, uint64_t* total_vulnerabilities, uint64_t* total_exploits) {
    if (!global_pentest_manager) return;
    
    if (total_sessions) *total_sessions = global_pentest_manager->total_sessions;
    if (total_targets) *total_targets = global_pentest_manager->total_targets;
    if (total_vulnerabilities) *total_vulnerabilities = global_pentest_manager->total_vulnerabilities;
    if (total_exploits) *total_exploits = global_pentest_manager->total_exploits;
}

/* Get session statistics */
void pentest_get_session_statistics(pentest_session_t* session, uint32_t* target_count, uint32_t* vulnerability_count, uint32_t* exploit_count) {
    if (!session) return;
    
    if (target_count) *target_count = session->target_count;
    if (vulnerability_count) *vulnerability_count = session->vulnerability_count;
    if (exploit_count) *exploit_count = session->exploit_count;
}

/* Get tool statistics */
void pentest_get_tool_statistics(pentest_tool_t* tool, uint64_t* total_runtime, uint64_t* total_targets, uint64_t* total_successes) {
    if (!tool) return;
    
    if (total_runtime) *total_runtime = tool->total_runtime;
    if (total_targets) *total_targets = tool->total_targets;
    if (total_successes) *total_successes = tool->total_successes;
}

/* Reset statistics */
void pentest_reset_statistics(void) {
    if (!global_pentest_manager) return;
    
    global_pentest_manager->total_sessions = 0;
    global_pentest_manager->total_targets = 0;
    global_pentest_manager->total_vulnerabilities = 0;
    global_pentest_manager->total_exploits = 0;
    global_pentest_manager->total_scans = 0;
    global_pentest_manager->total_attacks = 0;
    global_pentest_manager->total_successes = 0;
    global_pentest_manager->total_failures = 0;
    global_pentest_manager->total_runtime = 0;
}

/* Enable reconnaissance mode */
pentest_status_t pentest_enable_reconnaissance_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->reconnaissance_mode = true;
    vga_print_info("Reconnaissance mode enabled");
    return PENTEST_STATUS_OK;
}

/* Disable reconnaissance mode */
pentest_status_t pentest_disable_reconnaissance_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->reconnaissance_mode = false;
    vga_print_info("Reconnaissance mode disabled");
    return PENTEST_STATUS_OK;
}

/* Enable scanning mode */
pentest_status_t pentest_enable_scanning_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->scanning_mode = true;
    vga_print_info("Scanning mode enabled");
    return PENTEST_STATUS_OK;
}

/* Disable scanning mode */
pentest_status_t pentest_disable_scanning_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->scanning_mode = false;
    vga_print_info("Scanning mode disabled");
    return PENTEST_STATUS_OK;
}

/* Enable exploitation mode */
pentest_status_t pentest_enable_exploitation_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->exploitation_mode = true;
    vga_print_info("Exploitation mode enabled");
    return PENTEST_STATUS_OK;
}

/* Disable exploitation mode */
pentest_status_t pentest_disable_exploitation_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->exploitation_mode = false;
    vga_print_info("Exploitation mode disabled");
    return PENTEST_STATUS_OK;
}

/* Enable post exploitation mode */
pentest_status_t pentest_enable_post_exploitation_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->post_exploitation_mode = true;
    vga_print_info("Post exploitation mode enabled");
    return PENTEST_STATUS_OK;
}

/* Disable post exploitation mode */
pentest_status_t pentest_disable_post_exploitation_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->post_exploitation_mode = false;
    vga_print_info("Post exploitation mode disabled");
    return PENTEST_STATUS_OK;
}

/* Enable reporting mode */
pentest_status_t pentest_enable_reporting_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->reporting_mode = true;
    vga_print_info("Reporting mode enabled");
    return PENTEST_STATUS_OK;
}

/* Disable reporting mode */
pentest_status_t pentest_disable_reporting_mode(void) {
    if (!global_pentest_manager) return PENTEST_STATUS_ERROR;
    
    global_pentest_manager->reporting_mode = false;
    vga_print_info("Reporting mode disabled");
    return PENTEST_STATUS_OK;
}

/* Check if reconnaissance mode enabled */
bool pentest_is_reconnaissance_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->reconnaissance_mode : false;
}

/* Check if scanning mode enabled */
bool pentest_is_scanning_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->scanning_mode : false;
}

/* Check if exploitation mode enabled */
bool pentest_is_exploitation_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->exploitation_mode : false;
}

/* Check if post exploitation mode enabled */
bool pentest_is_post_exploitation_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->post_exploitation_mode : false;
}

/* Check if reporting mode enabled */
bool pentest_is_reporting_mode_enabled(void) {
    return global_pentest_manager ? global_pentest_manager->reporting_mode : false;
}

/* Stop tool */
pentest_status_t pentest_stop_tool(pentest_tool_t* tool) {
    if (!tool) return PENTEST_STATUS_INVALID_PARAM;
    if (!tool->running) return PENTEST_STATUS_ERROR;
    
    tool->running = false;
    tool->end_time = get_system_time();
    
    vga_printf("Stopped pentest tool: %s\n", tool->name);
    return PENTEST_STATUS_OK;
}

/* String comparison */
int strcmp(const char* s1, const char* s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char*)s1 - *(unsigned char*)s2;
}

/* String copy */
char* strncpy(char* dest, const char* src, size_t n) {
    char* original = dest;
    while (n-- && (*dest++ = *src++));
    while (n-- > 0) *dest++ = '\0';
    return original;
}

/* String formatting */
int sprintf(char* str, const char* format, ...) {
    /* Simple sprintf implementation */
    va_list args;
    va_start(args, format);
    
    int count = 0;
    while (*format) {
        if (*format == '%' && *(format + 1) == 's') {
            format += 2;
            char* s = va_arg(args, char*);
            while (*s) {
                *str++ = *s++;
                count++;
            }
        } else if (*format == '%' && *(format + 1) == 'u') {
            format += 2;
            unsigned int num = va_arg(args, unsigned int);
            /* Simple number to string conversion */
            char temp[16];
            int i = 0;
            if (num == 0) {
                temp[i++] = '0';
            } else {
                while (num > 0) {
                    temp[i++] = '0' + (num % 10);
                    num /= 10;
                }
            }
            while (i > 0) {
                *str++ = temp[--i];
                count++;
            }
        } else if (*format == '%' && *(format + 1) == 'l' && *(format + 2) == 'l' && *(format + 3) == 'u') {
            format += 4;
            unsigned long long num = va_arg(args, unsigned long long);
            /* Simple number to string conversion */
            char temp[32];
            int i = 0;
            if (num == 0) {
                temp[i++] = '0';
            } else {
                while (num > 0) {
                    temp[i++] = '0' + (num % 10);
                    num /= 10;
                }
            }
            while (i > 0) {
                *str++ = temp[--i];
                count++;
            }
        } else {
            *str++ = *format++;
            count++;
        }
    }
    
    *str = '\0';
    va_end(args);
    return count;
}

/* Get system time (placeholder) */
uint64_t get_system_time(void) {
    /* This would be implemented by the timer driver */
    return 0;
}

/* Memory functions */
void memory_zero(void* dest, size_t size) {
    uint8_t* d = (uint8_t*)dest;
    while (size--) *d++ = 0;
}

int memory_compare(const void* s1, const void* s2, size_t n) {
    const uint8_t* p1 = (const uint8_t*)s1;
    const uint8_t* p2 = (const uint8_t*)s2;
    while (n--) {
        if (*p1 != *p2) return *p1 - *p2;
        p1++;
        p2++;
    }
    return 0;
}

void memory_copy(void* dest, const void* src, size_t n) {
    uint8_t* d = (uint8_t*)dest;
    const uint8_t* s = (const uint8_t*)src;
    while (n--) *d++ = *s++;
}